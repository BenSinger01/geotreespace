#' MRCA vector function
#'
#' Function to find the location of the most recent common ancestor (MRCA) of each pair of tips in a tree.
#'
#' @author Benjamin John Singer \email{benjamin.singer@@bnc.ox.ac.uk}
#' @author Antonello Di Nardo \email{antonello.dinardo@@pirbright.ac.uk}
#' @author Luca Ferretti \email{luca.ferretti@@gmail.com}
#'
#' @param tree an object of the class \code{treedata}
#' @param mrca_matrix (optional) the matrix of most recent common ancestors of the tips of \code{tree} as generated by \code{linearMrca(tree@@phylo)}
#' 
#' @import treeio
#'
#'
mrcaVec <- function(tree,mrca_matrix=NULL){
  if (is.null(mrca_matrix)){
    mrca_matrix <-  linearMrca(tree@phylo)
  }
  mrca_vector <-  mrca_matrix[lower.tri(mrca_matrix)]
  mrca_location_vector <- character(length(mrca_vector))
  for(i in 1:length(mrca_vector)){
    mrca_location_vector[i] <-  tryCatch(toString(tree@data[tree@data$node==mrca_vector[i],"Location"]),
                                         warning = function(c) {return(toString(tree@data[tree@data$node==mrca_vector[i],"location"]))})
  }
  names(mrca_location_vector) <- mrca_vector
  return(mrca_location_vector)
}

#' Metric function
#'
#' Comparison of two phylogeographic trees using MRCA incompatibility
#'
#' @author Michelle Kendall \email{michelle.louise.kendall@@gmail.com}
#' @author Benjamin John Singer \email{benjamin.singer@@bnc.ox.ac.uk}
#' @author Antonello Di Nardo \email{antonello.dinardo@@pirbright.ac.uk}
#' @author Luca Ferretti \email{luca.ferretti@@gmail.com}
#'
#' @param tree.a an object of the class \code{treedata} or \code{character} (from mrcaVec)
#' @param tree.b an object of the class \code{treedata} (with the same tip labels as \code{tree.a}) or \code{character} (from mrcaVec)
#' @param distance.matrix a matrix of distances between locations as stored in the data of \code{tree.a} and \code{tree.b}. If not provided then the distance between all locations is set to one.
#' @param normalization If false then the distances are not normalized.
#' 
#' @return The distance between the two trees according to the metric
#'
#' @import treeio
#' 
#'
#' @export
mrcaDist <- function(tree.a, tree.b, distance.matrix = NULL, normalization = TRUE) {
  # check that the vectors are of the same class
  if(class(tree.a) != class(tree.b)){
    stop("Inputs are of different classes")
  } else if(inherits(tree.a,"treedata")) {
    if(length(tree.a@phylo$tip.label) != length(tree.b@phylo$tip.label)) stop("Trees must have the same number of tips")
    if(setequal(tree.a@phylo$tip.label,tree.b@phylo$tip.label) == FALSE) stop("Trees must have the same tip label sets")
    v1 <- mrcaVec(tree.a)
    v2 <- mrcaVec(tree.b)
  } else {
    v1 <- tree.a
    v2 <- tree.b
  }
  if (is.null(distance.matrix)){
    locs <- unique(c(v1,v2))
    distance.matrix <- 1-diag(length(locs))
    rownames(distance.matrix) <- locs
    colnames(distance.matrix) <- locs
  }
  if(inherits(v1,"character")) {
    I <- 0
    for (i in 1:length(v1)){
      I <- I + distance.matrix[v1[i],v2[i]]
    }
    if (normalization) {I = I/(choose(((1+sqrt(1+8*length(v1)))/2),2))}
    return(I)
  } else {
    # return an error message if the inputs are the wrong type
    stop("Inputs are not of the class treedata or character")
  }
}


#' Metric function for \code{multiPhylo} input
#'
#' Comparison of a list of phylogeographic trees using MRCA incompatibility.  Output is given as a pairwise distance matrix.
#'
#' @author Michelle Kendall \email{michelle.louise.kendall@@gmail.com}
#' @author Benjamin John Singer \email{benjamin.singer@@bnc.ox.ac.uk}
#' @author Antonello Di Nardo \email{antonello.dinardo@@pirbright.ac.uk}
#' @author Luca Ferretti \email{luca.ferretti@@gmail.com}
#'
#' @param trees an object of the class \code{multiPhylo} containing the trees to be compared
#' @param distance.matrix a matrix of distances between locations as stored in the data of the trees. If not provided then the distance between all locations is set to one.
#' @param normalization If false then the distances are not normalized
#' @param save.memory If true then MRCA vectors are created newly for each comparison
#' 
#' @return The distance between the two trees according to the metric
#'
#' @import treeio
#' 
#'
#' @export
multiMrcaDist <- function(trees, distance.matrix=NULL, normalization=TRUE, save.memory=FALSE){
  if(!inherits(trees, "multiPhylo")) stop("trees should be a multiphylo object")
  num_trees <- length(trees) 
  if(num_trees<2) {
    stop("multiMrcaDist expects at least two trees")
  }
  
  # make name labels well defined
  if(is.null(names(trees))) names(trees) <- 1:num_trees 
  else if(length(unique(names(trees)))!=num_trees){
    warning("duplicates detected in tree labels - using generic names")
    names(trees) <- 1:num_trees
  }
  lab <- names(trees)
  
  # check all trees have same tip labels
  for (i in 1:num_trees) {
    if (!setequal(trees[[i]]@phylo$tip.label,trees[[1]]@phylo$tip.label)) {
      stop(paste0("Tree ",lab[[i]]," has different tip labels from the first tree."))
    } 
  }
  
  # Here we speed up the computation by storing all vectors
  if(!save.memory){
    mrca_vectors <- sapply(1:num_trees,function(i){mrcaVec(trees[[i]])})
    
    mrca_indices_repeating <- unlist(sapply(1:(num_trees-1),function(i){replicate(num_trees-i,i)}))
    
    mrca_indices_cycling <- unlist(sapply(2:num_trees, function(i){i:num_trees}))
    
    distances_upper_tri <- mapply(function(i,j){mrcaDist(mrca_vectors[,i],mrca_vectors[,j],distance.matrix=distance.matrix)},mrca_indices_repeating,mrca_indices_cycling)
    
    distances <- matrix(0.0,num_trees,num_trees)
    distances[upper.tri(distances)] <- distances_upper_tri
    distances <- distances+t(distances)
  }
  
  # To save memory we recompute the vectors for each tree comparison (way slower but we don't eat a ton of memory).
  else{
    distances <- matrix(0.0,num_trees,num_trees)
    
    sapply(1:(num_trees-1),function(i) {
      sapply((i+1):num_trees, function(j) {
        distances[i,j] <<- distances[j,i] <<- mrcaDist(trees[[i]],trees[[j]],distance.matrix,normalization)
      })
    })
  }
  return(as.dist(distances))
}
