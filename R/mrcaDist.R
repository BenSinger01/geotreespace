#' MRCA vector function
#'
#' Function to find the location of the most recent common ancestor (MRCA) of each pair of tips in a tree.
#'
#' @author Benjamin John Singer \email{benjamin.singer@@bnc.ox.ac.uk}
#' @author Antonello Di Nardo \email{antonello.dinardo@@pirbright.ac.uk}
#' @author Luca Ferretti \email{luca.ferretti@@gmail.com}
#'
#' @param tree a tree object of the class \code{treedata}
#' @param coord_name (optional) a string specifying the attribute name used to indicate the geographic trait variable in the \code{treedata} object.
#' @param continuous (optional) logical specifying whether to expect discrete location trait (FALSE) or 2-dimensional geographic coordinates (TRUE).
#' @param mrca_matrix (optional) the matrix of most recent common ancestors of the tips of \code{tree} as generated by \code{linearMrca(tree@@phylo)} function of the \code{treespace} package
#'
#'
mrcaVec <- function(tree, coord_name="Location", continuous=FALSE, mrca_matrix=NULL) {
  if (is.null(mrca_matrix)) {
    mrca_matrix <- linearMrca(tree@phylo)
  }
  mrca_vector <- mrca_matrix[lower.tri(mrca_matrix)]
  if (continuous) {
    if (!paste0(coord_name, "1")%in%names(tree@data)) stop(paste0(coord_name, "is not a geographic locations variable contained in the tree"))
    mrca_location_vector <- array(numeric(2*length(mrca_vector)), dim=c(length(mrca_vector), 2))
    for (i in 1:length(mrca_vector)) {
      mrca_location_vector[i, 1] <- tree@data[tree@data$node==mrca_vector[i], paste(coord_name, "1", sep='')][[1]]
      mrca_location_vector[i, 2] <- tree@data[tree@data$node==mrca_vector[i], paste(coord_name, "2", sep='')][[1]]
    }
    rownames(mrca_location_vector) <- mrca_vector
  } else {
    mrca_location_vector <- character(length(mrca_vector))
    for (i in 1:length(mrca_vector)) {
      mrca_location_vector[i] <-  toString(tree@data[tree@data$node==mrca_vector[i], coord_name][[1]])
      names(mrca_location_vector) <- mrca_vector
    }
  }
  return(mrca_location_vector)
}

#' Pairwise MRCA metric function
#'
#' Comparison of two phylogeographic trees using the Pairwise Most-recent Common Ancestor (MRCA) incompatibility metric.
#'
#' @author Michelle Kendall \email{michelle.louise.kendall@@gmail.com}
#' @author Benjamin John Singer \email{benjamin.singer@@bnc.ox.ac.uk}
#' @author Antonello Di Nardo \email{antonello.dinardo@@pirbright.ac.uk}
#' @author Luca Ferretti \email{luca.ferretti@@gmail.com}
#'
#' @param tree.a an object of the class \code{treedata} or \code{character} (generated using the \code{mrcaVec} function)
#' @param tree.b an object of the class \code{treedata} (with the same tip labels as \code{tree.a}) or \code{character} (generated using the \code{mrcaVec} function)
#' @param coord_name (optional) a string specifying the attribute name used to indicate the geographic trait variable in the \code{treedata} object.
#' @param continuous (optional) logical specifying whether to expect discrete location trait (FALSE) or 2-dimensional geographic coordinates (TRUE).
#' @param distance.matrix (optional) a matrix of distances between locations as stored in the data of \code{tree.a} and \code{tree.b}. If not provided, and continuous = FALSE, then the distance between all locations is set to 1.
#' @param normalization (optional) logical specifiying whether distances should be normalised to account for the tree size.
#' 
#' @return The distance between the two trees according to the metric
#' 
#'
#' @export
mrcaDist <- function(tree.a, tree.b, coord_name="Location", continuous=FALSE, distance.matrix=NULL, normalization=TRUE) {
  # check that the vectors are of the same class
  if (any(class(tree.a) != class(tree.b))) {
    stop("Inputs are of different classes")
  } else if (inherits(tree.a, "treedata")) {
    if (length(tree.a@phylo$tip.label) != length(tree.b@phylo$tip.label)) stop("Trees must have the same number of tips")
    if (setequal(tree.a@phylo$tip.label, tree.b@phylo$tip.label) == FALSE) stop("Trees must have the same tip label sets")
    v1 <- mrcaVec(tree.a, coord_name=coord_name, continuous=continuous)
    v2 <- mrcaVec(tree.b, coord_name=coord_name, continuous=continuous)
  } else {
    v1 <- tree.a
    v2 <- tree.b
  }
  I <- 0
  if (inherits(v1, "character")) {
    if (is.null(distance.matrix)) {
      locs <- unique(c(v1, v2))
      distance.matrix <- 1-diag(length(locs))
      rownames(distance.matrix) <- locs
      colnames(distance.matrix) <- locs
    }
    for (i in 1:length(v1)) {
      I <- I + distance.matrix[v1[i], v2[i]]
    }
  } else if (inherits(v1,"array")) {
    for (i in 1:length(v1[, 1])) {
      I <- I + dist(rbind(v1[i, ], v2[i, ]))
    }
  } else {
    # return an error message if the inputs are the wrong type
    stop("Inputs are not of the class treedata or character")
  }
  if (normalization) {I = I/(choose(((1+sqrt(1+8*length(v1)))/2), 2))}
  return(I)
}


#' Metric function for \code{multiPhylo} input
#'
#' Comparison of a list of phylogeographic trees using the Pairwise Most-recent Common Ancestor (MRCA) incompatibility metric. Output is given as a pairwise distance matrix.
#'
#' @author Michelle Kendall \email{michelle.louise.kendall@@gmail.com}
#' @author Benjamin John Singer \email{benjamin.singer@@bnc.ox.ac.uk}
#' @author Antonello Di Nardo \email{antonello.dinardo@@pirbright.ac.uk}
#' @author Luca Ferretti \email{luca.ferretti@@gmail.com}
#'
#' @param trees an object of the class \code{multiPhylo} containing the trees to be compared
#' @param coord_name (optional) a string specifying the attribute name used to indicate the geographic trait variable in the \code{treedata} object.
#' @param continuous (optional) logical specifying whether to expect discrete location trait (FALSE) or 2-dimensional geographic coordinates (TRUE).
#' @param distance.matrix (optional) a matrix of distances between locations as stored in the data of \code{tree.a} and \code{tree.b}. If not provided, and continuous = FALSE, then the distance between all locations is set to 1.
#' @param normalization (optional) logical specifiying whether distances should be normalised to account for the tree size.
#' @param save.memory (optional) logical specifying whether MRCA vectors should be created newly for each comparison.
#' 
#' @return The distance between the two trees according to the metric
#' 
#'
#' @export
multiMrcaDist <- function(trees, coord_name="Location", continuous=FALSE, distance.matrix=NULL, normalization=TRUE, save.memory=FALSE) {
  if (!inherits(trees, "multiPhylo")) stop("trees should be a multiPhylo object")
  num_trees <- length(trees) 
  if (num_trees<2) {
    stop("multiMrcaDist function expects at least two trees")
  }
  
  # make name labels well defined
  if (is.null(names(trees))) {names(trees) <- 1:num_trees} 
  else if (length(unique(names(trees)))!= num_trees) {
    warning("duplicates detected in tree labels - using generic names")
    names(trees) <- 1:num_trees
  }
  lab <- names(trees)
  
  # check all trees have same tip labels
  for (i in 1:num_trees) {
    if (!setequal(trees[[i]]@phylo$tip.label, trees[[1]]@phylo$tip.label)) {
      stop(paste0("Tree ", lab[[i]], " has different tip labels from the first tree."))
    } 
  }
  
  # Here we speed up the computation by storing all vectors
  if (!save.memory) {
    mrca_vectors <- sapply(1:num_trees, function(i) {mrcaVec(trees[[i]], coord_name, continuous)})
    
    mrca_indices_repeating <- unlist(sapply(1:(num_trees-1), function(i) {replicate(num_trees-i, i)}))
    
    mrca_indices_cycling <- unlist(sapply(2:num_trees, function(i) {i:num_trees}))
    
    if (continuous) {
      n = length(mrca_vectors)/(num_trees*2)
      distances_upper_tri <- mapply(function(i, j) {mrcaDist(array(mrca_vectors[, i], dim=c(n, 2)), array(mrca_vectors[, j], dim=c(n, 2)), distance.matrix=distance.matrix)}, mrca_indices_repeating, mrca_indices_cycling)
    } else {
      distances_upper_tri <- mapply(function(i,j) {mrcaDist(mrca_vectors[, i], mrca_vectors[, j], distance.matrix=distance.matrix)}, mrca_indices_repeating, mrca_indices_cycling)
    }
    distances <- matrix(0.0, num_trees, num_trees)
    distances[upper.tri(distances)] <- distances_upper_tri
    distances <- distances+t(distances)
  
  # To save memory we recompute the vectors for each tree comparison (way slower but we don't eat a ton of memory).
  } else {
    distances <- matrix(0.0, num_trees, num_trees)
    
    sapply(1:(num_trees-1), function(i) {
      sapply((i+1):num_trees, function(j) {
        distances[i, j] <<- distances[j,i] <<- mrcaDist(trees[[i]], trees[[j]], coord_name, continuous, distance.matrix, normalization)
      })
    })
  }
  return(as.dist(distances))
}
